---
title: Haskell package checklist
---

- Host on GitHub
  - Easy for other developers to contribute.
  - Integrates well with other services.
  - More popular than other hosts.
- Build with Stack
  - Easiest way to manage dependencies.
  - Ensures that your package will remain buildable.
  - Makes difficult workflows easy, like `--profile` and `--coverage`.
- Use `hpack`
  - Uses YAML instead of custom package format.
  - Avoids unnecessary boilerplate.
  - Integrated directly into Stack.
- Name package with `kebab-case`
  - Keep everything lowercase to avoid confusion.
  - Use hyphens to separate words.
  - Keep it short and memorable.
- Use Semantic Versioning
  - SemVer is used by many other languages.
  - It matches how developers generally think about versions.
  - Hackage recommends the PVP, which adds ambiguity.
- Choose a license
  - Packages without a license can’t really be used.
  - BSD-3-Clause is the most popular, followed by MIT.
  - Include the license file as well.
- Write a README
  - This is how most people will become familiar with your package.
  - Describe the problem the package solves.
  - Provide at least one concrete example.
- Keep a change log
  - Use Git tags to mark versions.
  - Reading diffs is not an acceptable way for users to discover changes.
  - GitHub releases are a great place to put human-readable changes.
- Write a `synopsis`
  - This shows up when searching and viewing your package.
  - Make it short, imperative, and descriptive.
  - Use the same thing in the `description` prefixed with the package name.
- Avoid heavy dependencies
  - Only add a dependency if it’s necessary, not just nice to have.
  - For example, generally avoid `lens`.
  - Similarly, avoid having too many dependencies.
- Include `extra-source-files`
  - If it’s necessary in order to build, put it in here.
  - Keep it as small as possible.
  - Also include things for tests and benchmarks.
- Keep executables small
  - Define the executable in your library and re-export it.
  - This allows others to use your executable’s behavior from Haskell.
  - Avoid re-defining main because it causes problems with GHCi.
- Avoid package warnings
  - Stack prints these out when you run `stack sdist`.
  - Some of the warnings, like category and description, are annoying.
  - Generally using `--pvp-bounds=both` is good.
- Build `-Wall` clean
  - GHC can find all kinds of problems but doesn’t by default.
  - Few false positives, generally helps you write better code.
  - You can ignore specific warnings with `-fno-warn-whatever`.
- Put everything in `source/`
  - This separates Haskell files from package metadata.
  - Makes it easy to search and script Haskell files.
  - Looks like `source/library/Foo.hs`, `source/executables/Main.hs`, `source/tests/Main.hs`, `source/benchmarks/Main.hs`, and so on.
- Match module and package names
  - Module names use `CamelCase`, package names use `kebab-case`.
  - If you package is named `foo-bar`, you should have a top-level module called `FooBar`.
  - Not `Data.FooBar` or `Text.ParserCombinators.FooBar`.
- Require one import
  - Users should be able to hit the ground running with `import FooBar`.
  - If necessary, re-export functions from other packages.
  - Optimize for qualified imports, so don’t be afraid to take common names.
- Document with examples
  - Types are good, but they’re not documentation.
  - The same is true for laws.
  - Usually functions are added to solve a problem. Show that problem in the documentation as an example.
- Expose implementation details
  - People will use your package in ways you didn’t think of.
  - Make everything public, but not necessarily published.
  - Use `Internal` module names to signal that they’re private.
- Follow most HLint suggestions
  - Overall a great tool that helps you write better software.
  - Some suggestions aren’t worth following.
  - In particular the re-export shortcut and anything involving operators.
- Format code with `hindent`
  - This frees you up to never think about formatting again.
  - Improving `hindent` improves formatting for everyone.
  - Side steps useless arguments in pull requests.
- Test with Tasty using Hspec
  - Tasty is a testing framework for running different kinds of tests.
  - Hspec tests are the nicest to write.
  - Use other providers like QuickCheck when they make sense.
- Benchmark with Criterion
  - Only if your package needs to be fast!
  - Otherwise this is a lot of overhead to maintain.
  - Criterion is the gold standard for pretty much any language.
- Run tests on Travis CI
  - Travis CI is free and integrates with GitHub.
  - You can run tests on Linux and macOS.
  - Consider also using AppVeyor for Windows builds.
- Build and test with `--pedantic`
  - This forces you to fix warnings.
  - Particularly useful as new versions of GHC and dependencies come out.
  - Be sure to not use `--pedantic` when building dependencies to avoid unnecessary build failures.
- Automate releases
  - Most CI services set an environment variable when building a Git tag.
  - Upload packages to Hackage from CI using `stack upload .`.
  - Be sure not to leak credentials into build log.
  
