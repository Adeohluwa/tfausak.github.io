---
title: Clojure's threading macros
---

- recently learned clojure
- my first lisp
- i enjoyed it
- i was pleasantly surprised to learn about threading macros
- the seemed like a better version of flow
- [flow]({% post_url 2015-04-09-write-more-understandable-haskell-with-flow %})

- let's loo k at the `euler8` function
- assume that `takes` already exists

``` clj
(defn takes [n xs]
  (if (seq xs)
    (cons (take n xs) (takes n (rest xs)))
    ()))
```

- here it is in idiomatic clojure

``` clj
(defn euler8 [n xs]
  (apply max
    (map #(apply * %)
      (takes n
        (map #(Character/getNumericValue %)
          (filter #(Character/isDigit %) xs))))))
```

- it is kind of hard to understand
- it can be rewritten with the thread last macro
- [->>](https://clojuredocs.org/clojure.core/-%3E%3E)

``` clj
(defn euler8 [n xs]
  (->> xs
       (filter #(Character/isDigit %))
       (map #(Character/getNumericValue %))
       (takes n)
       (map #(apply * %))
       (apply max)))
```

- we basically got lucky that it was always the last argument
- sometimes you want it to be the first argument
- in those instances you can use the thread first macro
- [->](https://clojuredocs.org/clojure.core/-%3E)

- i was surprised that these were idiomatic clojure
- considering the response to flow in haskell
- this makes me think that the clojure community is more pragmatic

- in fact there is a package with even more powerful macros
- swiss arrows adds the diamond wand, among others
- [-<>](https://github.com/rplevy/swiss-arrows)

- the first time i saw this i thought it was a joke
- i didn't understand what it did or why it was useful
- but it's both powerful and helps write more understandable code

- instead of implicitly inserting an argument
- it lets you drop a sigil where you want the argument
- `<>`
- so the example from before gets a little better

``` clj
(defn euler8 [n xs]
  (-<> xs
       (filter #(Character/isDigit %) <>)
       (map #(Character/getNumericValue %) <>)
       (takes n <>)
       (map #(apply * % ) <>)
       (apply max <>)))
```

- you can follow the `<>` to see where data flows.
- another way to do this is the as-> macro
- it's even in core!
- [as->](http://clojuredocs.org/clojure.core/as-%3E)

``` clj
(defn euler8 [n xs]
  (as-> xs $
       (filter #(Character/isDigit %) $)
       (map #(Character/getNumericValue %) $)
       (takes n $)
       (map #(apply * % ) $)
       (apply max $)))
```

- thanks to macros
- there are lots of idiomatic ways to write imperative-looking code in clojure
- the only way haskell can be this expressive is with template haskell
