---
layout: post
title: untitled
---

(ruby 1.9.3-p392 / rails 3.2.13 / bcrypt-ruby 3.0.1)

every so often i hear about a database leaking
usually they have a bunch of email addresses and passwords
users of whatever service got hacked should be concerned
in decreasing terms of badness, this is how passwords are stored:

1. in plain text
2. obfuscated (rot13/caesar cypher)
3. encrypted (3des)
4. hashed (md5, sha-1, etc.)
5. salted and hashed
6. key derivation function'd (bcrypt, pbkdf2, etc.)

i hear about these leaks through hacker news or reddit
invariably the comments decry the database's company as incompetent
why are they not using bcrypt? don't they know better?

most people do know better
but the cost/benefit doesn't always make sense
securing password storage protects against one thing only:
leaking a database
that's a pretty rare occurrence
there is usually lower-hanging security fruit to go after first

all that being said, it's better to use bcrypt
there's no reason not to
and it's surprisingly easy to update a legacy system to use it

## before

let's say you're in the worst case scenario
you store passwords in plain text
(this is really bad but it makes for a simpler example)
yuo might handle authentication through a class method
here's how it might look

{% highlight ruby %}
class Account < ActiveRecord::Base
  def self.authenticate(username, password)
    account = find_by_username(username)
    account if account && password == account.password
  end
end
{% endhighlight %}

nothing too complicated
pass it the username and password from a form
if they authenticate, it returns the account
if they don't, it returns nil

## during

let's upgrade to the best case scenario: bcrypt
we'll need another field in our model
and a handful of new methods
and we'll need to change the authenticate method

{% highlight ruby %}
# bundle exec rails generate migration add_bcrypt_hash_to_account bcrypt_hash:string
class AddBcryptHashToAccount < ActiveRecord::Migration
  def change
    add_column :accounts, :bcrypt_hash, :string
  end
end
{% endhighlight %}

then you'll want to be able to tell if someone has their password bcrypted or not
and you'll want to set it and compare to it
this is pretty easy using the bcrypt-ruby gem
(so, you know, add `gem 'bcrypt-ruby'` to your gemfile)

{% highlight ruby %}
require 'bcrypt'

class Account < ActiveRecord::Base
  include BCrypt

  def bcrypt?
    bcrypt_hash.present?
  end

  def bcrypt
    @bcrypt ||= Password.new(bcrypt_hash) if bcrypt?
  end

  def bcrypt=(new_password)
    @bcrypt = Password.create(new_password)
    self.bcrypt_hash = @bcrypt
  end
end
{% endhighlight %}

finally we need to modify the authenticate function
it should do a few things:

- if the account is using bcrypt, compare against that
- otherwise, compare against the old method (plain text)
- after authenticating the old way, update to bcrypt
- remove old password when updating

{% highlight ruby %}
def self.authenticate(username, password)
  account = find_by_username(username)
  return unless account
  if account.bcrypt?
    account if password == account.bcrypt
  elsif password == account.password
    account.bcrypt = password
    account.password = nil
    account.save!
    account
  end
end
{% endhighlight %}

that's all you have to do!
bcrypt handles setting the number of rounds and adding a salt
at some point in the future you might have to change the rounds
the default is 10
`BCrypt::Engine.cost = 13`
https://github.com/codahale/bcrypt-ruby#cost-factors

## after

at some point you'll need to wipe all traces of the old data
give your users plenty of time to transparently update
at the cutoff, you'll need to run a migration
and probably send some emails

{% highlight ruby %}
# bundle exec rails generate migration remove_password_from_account
require 'bcrypt'

class RemovePasswordFromAccount < ActiveRecord::Migration
  def up
    account_ids = ActiveRecord::Base.connection.
      select_all('SELECT id FROM accounts WHERE bcrypt_hash IS NULL').
      map { |e| e['id'] }
    passwords = account_ids.
      map { SecureRandom.hex(4) }
    bcrypt_hashes = passwords.
      map { |e| BCrypt::Password.create(e) }
    cases = account_ids.zip(bcrypt_hashes).
      map { |a, b| "WHEN #{a} THEN '#{b}'" }

    if account_ids.present?
      update_sql <<-SQL
        UPDATE accounts
        SET bcrypt_hash = CASE id #{cases.join(' ')} END
        WHERE id IN (#{account_ids.join(', ')})
      SQL
    end

    remove_column :accounts, :password
  end

  def down
    add_column :accounts, :password, :string
  end
end
{% endhighlight %}

you should probably do something with `account_ids` and `passwords`
maybe dispatch an email to those users
or write them out to a file and do something with them later
or your users can just rely on your site's password recovery options

## testing

depending on how your tests are set up, using bcrypt might slow them down
you can change the default cost when testing
setting it to 1 (from 10) speeds it up by about 55 times

{% highlight ruby %}
# spec/support/bcrypt.rb
require 'bcrypt'

module BCrypt
  class Engine
    Kernel.silence_warnings do
      DEFAULT_COST = 1
    end
  end
end
{% endhighlight %}
