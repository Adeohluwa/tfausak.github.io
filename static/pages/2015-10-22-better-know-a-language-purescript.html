<!doctype html>

<html>
  <head>
    <meta charset="utf-8">

    <title>Better know a language: PureScript</title>

    <style>
      body {
        font-family: 'Avenir Next', sans-serif;
      }
      .remark-code {
        font-family: 'Source Code Pro', monospace;
      }
      blockquote {
        font-size: 2em;
      }
    </style>
  </head>

  <body>
    <textarea id="source">
class: center, middle

<img alt="" src="/static/images/2015/10/22/purescript.svg" width="350" height="220">

<h1>
  Better know a language
  <br>
  PureScript
</h1>

<p>
  by Taylor Fausak
  <br>
  on October 22, 2015
</p>

???

For more information about this talk, including a recording of it, please go to
its event page on Google+ at:
<https://plus.google.com/events/cpomrpac6ag61e85e6kponsc44o>

---

# What is PureScript?

According to the PureScript website,

> PureScript is a small strongly typed programming language that compiles to
> JavaScript.

---

# What is PureScript?

According to the `purescript` package,

> A small strongly, statically typed programming language with expressive
> types, inspired by Haskell and compiling to Javascript.

---

# What is PureScript?

Colloquially,

> Haskell for JavaScript

---

# Why PureScript?

There are other Haskell-to-JavaScript projects, like

- Emscripten: converts LLVM bytecode (from GHC) to JavaScript
- Fay: compiles a subset of Haskell to JavaScript
- GHCJS: compiles GHC Haskell to JavaScript
- Haste: compiles Haskell to JavaScript
- UHC: can compile Haskell to JavaScript back end

There are also Haskell-like languages that compile to JavaScript, like

- Elm: focuses on functional-reactive programming (FRP) in the browser
- JMacro: generates JavaScript in Haskell
- Roy: experimental Haskell-like language that compiles to JavaScript

---

# Why PureScript?

PureScript does not attempt to preserve Haskell's semantics. That means

- There is no runtime.
- It's strict instead of lazy.
- It's foreign function interface (FFI) is easier to use.
- It integrates well with existing JavaScript packages.

---

# Why PureScript?

Why should you use PureScript instead of some other Haskell-like thing?

- Compared to projects like Emscripten and UHC, the output should be smaller
  and more readable.
- Compared to languages that preserve Haskells semantics like Fay, GHCJS, and
  Haste, there is no runtime.
- Compared to code generators like JMacro, you don't have to get Haskell
  involved at all.
- Compared to front end languages like Elm, you can run PureScript on Node.js.

---

# What does PureScript look like?

The classic "hello world" is short and sweet.

```
module Main where
import Control.Monad.Eff.Console
main = log "Hello from PureScript!"
```

"Eff" is short for "effect", meaning it's impure.

---

# What does PureScript look like?

This is how a real file might look.

```
module Main (main) where

import Prelude

import qualified Control.Monad.Eff as Eff
import qualified Control.Monad.Eff.Console as Console

main :: Eff.Eff (console :: Console.CONSOLE) Unit
main = do
  Console.log "Hello from PureScript!"
```

It was typed before, but now it's explicit.

---

# What does PureScript look like?

The generated JavaScript is "human-readable".

``` js
// Generated by psc version 0.7.4.1
"use strict";
var Control_Monad_Eff_Console = require("Control.Monad.Eff.Console");
var main = Control_Monad_Eff_Console.log("Hello from PureScript!");
module.exports = {
    main: main
};
```

---

# What do you get from PureScript?

- Algebraic data types
- Pattern matching
- Type inference
- Type classes
- Higher kinded types
- Rank-N types
- Extensible records
- Extensible effects
- Modules
- Simple FFI
- No runtime system
- Human-readable output

---

# What do you get from PureScript?

TL;DR

> Haskell plus extensible records and effects (minus some esoteric stuff)

---

# Extensible records

This is also known as row polymorphism, structural typing, or static duck
typing. And it's *the coolest thing* about PureScript.

```
fullName person = person.first ++ " " ++ person.last
fullName { first: "Taylor", last: "Fausak" }
-- "Taylor Fausak"
```

Writing functions like this in Haskell is annoying. It requires something like
type classes or lenses. Extensible records make it almost trivial.

---

# Extensible records

This function can also be written with pattern matching.

```
fullName { first: f, last: l } = f ++ " " ++ l
```

---

# Extensible records

This is the type signature for `fullName`.

```
fullName :: forall r. { first :: String, last :: String | r } -> String
```

It means that it's argument must have both "first" and "last" string fields. It
may have more, but it must have at least those. And they must be the right
type.

---

# Extensible records

Missing a field will give an error.

```
fullName { first: "Taylor" }
-- Error checking that type
--   { first :: Prim.String }
-- subsumes type
--   { last :: Prim.String, first :: Prim.String | r }
```

---

# Extensible records

A field with the wrong type will give an error.

```
fullName { first: "Taylor", last: 123 }
-- Error checking that type
--   { last :: Prim.Int, first :: Prim.String }
-- subsumes type
--   { last :: Prim.String, first :: Prim.String | r }
```

---

# Extensible records

Adding extra fields is fine.

```
fullName { first: "Taylor", last: "Fausak", age: 26 }
-- "Taylor Fausak"
```

If you want to disallow extra fields, you can say that in with the type.

```
fullName  :: forall r. { first :: String, last :: String | r } -> String
fullName' ::           { first :: String, last :: String     } -> String
```

This means that the record must have *exactly* these fields and no more.

---

# Extensible records

With the new type signature, an extra field will give an error.

```
fullName' { first: "Taylor", last: "Fausak", age: 26 }
-- Error checking that type
--   { age :: Prim.Int, last :: Prim.String, first :: Prim.String }
-- subsumes type
--   { last :: Prim.String, first :: Prim.String }
```

---

# Extensible records

Those type signatures quickly get annoying. Fortunately type aliases make it
better.

```
type Person = forall r. { first :: String, last :: String | r }
fullName :: Person -> String

type Person' = { first :: String, last :: String }
fullName' :: Person' -> String
```

---

# Extensible records

With extensible records, you could accidentally allow a program to type check
because you passed a record that just so happened to have the right fields. If
you want stronger guarantees, you can use `newtype`.

```
newtype Person = Person { first :: String, last :: String }

fullName :: Person -> String
fullName (Person person) = person.first ++ " " ++ person.last

fullName (Person { first: "Taylor", last: "Fausak" })
-- "Taylor Fausak"

fullName { first: "Taylor", last: "Fausak" }
-- Error checking that type
--   { last :: Prim.String, first :: Prim.String }
-- subsumes type
--   Main.Person
```

---

# Extensible effects

Extensible effects are like extensible records for the type system. We've
actually already seen them. Remember this type signature?

```
main :: Eff.Eff (console :: Console.CONSOLE) Unit
```

It means that the `main` function uses the `CONSOLE` effect. Which basically
means that it can print stuff out. This is way more granular than Haskell's
`IO` type, which allows you to do pretty much anything.

---

# Extensible effects

While this granularity can be nice, it can also get out of control quickly.

```
main :: Eff ( console :: CONSOLE
            , random :: RANDOM
            , err :: EXCEPTION
            , dom :: DOM
            -- ad naseum
            ) Unit
```

This is why you'll often see PureScript programs without type signatures on
`main`. I suppose this isn't any worse than Haskell's `main :: IO ()`, but it
feels annoying to work with. It reminds me of Java's checked exceptions.

---

# FFI: PureScript from JavaScript

Calling PureScript from JavaScript is pretty straightforward.

```
module A where
import Prelude
add x y = x + y
```

The only gotcha is that all functions are curried.

``` js
var A = require('A');
A.add(3)(4);
// 7
```

---

# FFI: JavaScript from PureScript

For simple values, the FFI is nice. You just have to supply the type signature.

```
module URI where
foreign import encodeURIComponent :: String -> String
```

``` js
// module URI
exports.encodeURIComponent = encodeURIComponent;
```

```
import URI
encodeURIComponent "hello world"
-- "hello%20world"
```

---

# FFI

TL;DR: It's there. It works. Going from untyped to typed sucks.

---

class: center, middle

# Real world

---

class: center, middle

<img alt="" src="/static/images/2015/10/22/purescript.svg" width="350" height="220">

# Questions?
    </textarea>

    <script src="/static/scripts/remark-0.12.0.min.js"></script>
    <script>
      remark.create({
        highlightLanguage: 'purescript',
        ratio: '16:9'
      });
    </script>

    <script async src="/static/scripts/all.js"></script>

    <noscript>
        <img alt="" src="http://piwik.fausak.me/piwik.php?idsite=1">
    </noscript>
  </body>
</html>
